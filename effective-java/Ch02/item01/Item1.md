###생성자(Constructor) 란?
클래스의 객체가 인스턴스화될 때, 반드시 자동으로 호출되는 특수한 메소드, 멤버 변수를 초기화하는 역할이다.

###정적 팩터리 메소드(static factory method) 란?
객체를 생성하는 메소드를 만들고 static으로 선언하는, 객체 생성을 캡슐화하는 기법이다. 

--------------------------------------------

## 정적 팩터리 메서드 사용의 장점

1. 이름을 가질 수 있다.
   - Order 이라는 생성자보다, productOrder, urgentOrder 가 더 잘 표현되어 있다.

2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
   - 반복되는 요청에 같은 객체를 반환한다. (대표적 예인 Boolean.valueOf(boolean) 메서드는 객체를 아예 생성하지 않는다.)
   - 인스턴스 통제(instance-controlled) 클래스 : 언제 어느 인스턴스를 살아 있게 할지를 통제하는 클래스
     인스턴스를 통제하면 클래스를 싱글턴으로 만들 수도, 인스턴스화 불가로 만들 수도 있다. 
      - 생성자의 경우 사용하는 입장에서 객체 생성을 맘대로 생성할 수 있지만, 
        팩터리의 경우 객체 생성을 막고 인스턴스를 통제할 수 있다. 
      - 플라이웨이트 패턴 : 자주 사용하는 값들을 미리 캐싱해서 넣어둔 후, 꺼내다가 쓰는 디자인 패턴

3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
   - 반환할 객체의 클래스를 자유롭게 선택할 수 있다.
     - 해당하는 Class의 인스턴스뿐 아니라, 반환 Type에 호환 가능한 다른 타입의 인스턴스를 줘도 된다.
   - API를 만들 때 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있다.

4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
   - 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관 없다.
   - 클라이언트는 팩토리가 제공해주는 객체가 어떤 클래스의 인스턴스인지 알 수도 없고, 알 필요도 없다.
   - 예를 들어, EnumSet 클래스는 원소의 수에 따라 두 가지 하위 클래스 중 하나의 인스턴스를 반환한다. 원소가 64개 이하면 RegularEnumSet 인스턴스를, 65개 이상이면 JumboEnumSet를 반환하지만, 클러이언트는 이 두 클래스의 존재를 모른다. 

5. 정적 팩터리 메소드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
   - 예를 들어, A 란 인터페이스가 있을때 이걸 누가 구현해서 쓸지는 모르는 상황이다. A 는 인터페이스 이므로 클래스 생성자 같이 생성자를 만들어 줄수는 없고, 구
     현체가 없기 떄문에 클래스 생성자도 만들수 없는 상황이다. 이 때, 스태틱 팩토리 메서드를 이용하면 A 를 반환하는 생성자 역할을 하는 메소드를 만들어 놓을 수 있다
   - HelloServiceFactory 소스를 보면, HelloSerivce라는 인터페이스의 구현체를 만들어 놓지 않아도
     ServiceLoader를 통해 다른 참조할 수 있는 구현체를 가져올 수 있다. (설명 참조)


------------------------------------------------------------

## 정적 팩터리 메서드 사용의 단점

1. 상속을 허용하지 않는다. 
    - 생성자를 막아놓은 경우 상속하기 어렵다.

2. 정적 팩터리 메소드는 프로그래머가 찾기 어렵다.
    - 메서드 이름을 널리 알려진 규약을 따라 짓는 식으로 문제를 완화해야 한다. (ex. of, getInstance 등)
    - 문서화를 잘하다 (자바독)